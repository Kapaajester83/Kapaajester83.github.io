<!DOCTYPE html>
<html lang="en-US">

<head>
  <link rel="icon" type="image/png" sizes="48x48" href="../../../favicon.ico">
  <link rel="shortcut icon" href="../../../favicon.ico">
  <title>Hack The Box | Fundamentals of AI</title>
  <meta name="author" content="Kappa">
  <meta name="description" content="Splash">
  <meta name="viewport" content="width=device-width">
  <link href='https://fonts.googleapis.com/css?family=Rock+Salt' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Orbitron:500' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Rochester' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="../../labs.css" type="text/css">
</head>

<body>

  <!--
  _  __          _____  _____        
 | |/ /    /\   |  __ \|  __ \ /\    
 | ' /    /  \  | |__) | |__) /  \   
 |  <    / /\ \ |  ___/|  ___/ /\ \  
 | . \  / ____ \| |    | |  / ____ \ 
 |_|\_\/_/    \_\_|    |_| /_/    \_\
 
 -->

  <div id="page">
    <div id="nav">
      <ul>
        <li><a href="https://kapaajester83.github.io/">Home</a></li>
        <li><a href="https://kapaajester83.github.io/labs/contents.html">Labs</a></li>
        <li><a href="https://duckduckgo.com/" target="_blank">DuckGo</a></li>
        <li><a href="https://github.com/Kapaajester83?tab=repositories" target="_blank">About</a></li>
        <li><a href="mailto:kappajester83@gmail.com" target="_blank">Email</a></li>
      </ul>
    </div>
    <div id="logo">
      <img src="https://kapaajester83.github.io/logo.jpeg" alt="logo">
      <h1>Kappa</h1>

      <div>
        <br>
        <br>
        <br>
        <h2>“Great things are not done by impulse, but by a series of small things brought together.”</h2>
        <br>
        <br>
      </div>
    </div>

    <div id="writeup">
      <h3>
        <a href="../../contents.html">Hack The Box</a>
      </h3>
      <hr>

      <div id="labs-table-top">

        <h4><a href="../fundamentalsAI.htm">Fundamentals of AI</a></h4>
        <ul>
          <li><a href="logisticRegression.htm">Logistic Regression</a></li>
          <li><a href="decisionTrees.htm"><b><em>~ Decision Trees</em></b></a></li>
          <li><a href="naiveBayes.htm">Naive Bayes</a></li>
        </ul>
      </div>
      <hr>

      <div>

        <h3><em>Decision Trees</em></h3>

        <p>Decision trees are a popular supervised learning algorithm for classification and regression tasks. They are known for their intuitive tree-like structure, which makes them easy to understand and interpret. In essence, a decision tree creates a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
        <ul>
          <li><a href="https://academy.hackthebox.com/storage/modules/290/decision_tree.png">https://academy.hackthebox.com/storage/modules/290/decision_tree.png</a></li>
        </ul>

        <p>Imagine you're trying to decide whether to play tennis based on the weather. A decision tree would break down this decision into a series of simple questions: Is it sunny? Is it windy? Is it humid? Based on the answers to these questions, the tree would lead you to a final decision: play tennis or don't play tennis.</p>

        <p>A decision tree comprises three main components:
        <ul>
          <li><b>Root Node:</b> - This represents the starting point of the tree and contains the entire dataset.</li>
          <li><b>Internal Nodes:</b> - These nodes represent features or attributes of the data. Each internal node branches into two or more child nodes based on different decision rules.</li>
          <li><b>Leaf Nodes:</b> - These are the terminal nodes of the tree, representing the final outcome or prediction.</li>
        </ul>

        <h4>Building a Decision Tree</h4>

        <p>Building a decision tree involves selecting the best feature to split the data at each node. This selection is based on measures like Gini impurity, entropy, or information gain, which quantify the homogeneity of the subsets resulting from the split. The goal is to create splits that result in increasingly pure subsets, where the data points within each subset belong predominantly to the same class.</p>

        <h4>Gini Impurity</h4>

        <p>Gini impurity measures the probability of misclassifying a randomly chosen element from a set. A lower Gini impurity indicates a more pure set. The formula for Gini impurity is:</p>

        <pre>
          Gini(S) = 1 - Σ (pi)^2

          Where:
            S is the dataset.
            pi is the proportion of elements belonging to class i in the set.
        </pre>

        <p>Consider a dataset S with two classes: A and B. Suppose there are 30 instances of class A and 20 instances of class B in the dataset.</p>

        <pre>
          Proportion of class A: pA = 30 / (30 + 20) = 0.6
          Proportion of class B: pB = 20 / (30 + 20) = 0.4
        </pre>

        <p>The Gini impurity for this dataset is:</p>

        <pre>
          Gini(S) = 1 - (0.6^2 + 0.4^2) = 1 - (0.36 + 0.16) = 1 - 0.52 = 0.48
        </pre>

        <h4>Entropy</h4>

        <p>Entropy measures the disorder or uncertainty in a set. A lower entropy indicates a more homogenous set. The formula for entropy is:

        <pre>
          hbEntropy(S) = - Σ pi * log2(pi)

          Where:
            S is the dataset.
            pi is the proportion of elements belonging to class i in the set.
        </pre>

        <p>Using the same dataset S with 30 instances of class A and 20 instances of class B:</p>

        <pre>
          Proportion of class A: pA = 0.6
          Proportion of class B: pB = 0.4
        </pre>

        <p>The entropy for this dataset is:</p>

        <pre>
          Entropy(S) = - (0.6 * log2(0.6) + 0.4 * log2(0.4))
                     = - (0.6 * (-0.73697) + 0.4 * (-1.32193))
                     = - (-0.442182 - 0.528772)
                     = 0.970954
        </pre>

        <h4>Information Gain</h4>

        <p>Information gain measures the reduction in entropy achieved by splitting a set based on a particular feature. The feature with the highest information gain is chosen for the split. The formula for information gain is:</p>

        <pre>
          Information Gain(S, A) = Entropy(S) - Σ ((|Sv| / |S|) * Entropy(Sv))

          Where:
            S is the dataset.
            A is the feature used for splitting.
            Sv is the subset of S for which feature A has value v.
        </pre>

        <p>Consider a dataset S with 50 instances and two classes: A and B. Suppose we consider a feature F that can take on two values: 1 and 2. The distribution of the dataset is as follows:</p>

        <pre>
          For F = 1: 30 instances, 20 class A, 10 class B
          For F = 2: 20 instances, 10 class A, 10 class B
        </pre>

        <p>First, calculate the entropy of the entire dataset S:</p>

        <pre>
          Entropy(S) = - (30/50 * log2(30/50) + 20/50 * log2(20/50))
                     = - (0.6 * log2(0.6) + 0.4 * log2(0.4))
                     = - (0.6 * (-0.73697) + 0.4 * (-1.32193))
                     = 0.970954
        </pre>

        <p>Next, calculate the entropy for each subset Sv:</p>

        <pre>
          For F = 1:
            Proportion of class A: pA = 20/30 = 0.6667
            Proportion of class B: pB = 10/30 = 0.3333
            Entropy(S1) = - (0.6667 * log2(0.6667) + 0.3333 * log2(0.3333)) = 0.9183
          For F = 2:
            Proportion of class A: pA = 10/20 = 0.5
            Proportion of class B: pB = 10/20 = 0.5
            Entropy(S2) = - (0.5 * log2(0.5) + 0.5 * log2(0.5)) = 1.0
        </pre>

        <p>Now, calculate the weighted average entropy of the subsets:</p>

        <pre>
          Weighted Entropy = (|S1| / |S|) * Entropy(S1) + (|S2| / |S|) * Entropy(S2)
                           = (30/50) * 0.9183 + (20/50) * 1.0
                           = 0.55098 + 0.4
                           = 0.95098
        </pre>

        <p>Finally, calculate the information gain:</p>

        <pre>
          Information Gain(S, F) = Entropy(S) - Weighted Entropy
                                 = 0.970954 - 0.95098
                                 = 0.019974
        </pre>

        <h4>Building the Tree</h4>

        <p>The tree starts with the root node and selects the feature that best splits the data based on one of these criteria (Gini impurity, entropy, or information gain). This feature becomes the internal node, and branches are created for each possible value or range of values of that feature. The data is then divided into subsets based on these branches. This process continues recursively for each subset until a stopping criterion is met.</p>

        <p>The tree stops growing when one of the following conditions is satisfied:
        <ul>
          <li><b>Maximum Depth:</b> - The tree reaches a specified maximum depth, preventing it from becoming overly complex and potentially overfitting the data.</li>
          <li><b>Minimum Number of Data Points:</b> - The number of data points in a node falls below a specified threshold, ensuring that the splits are meaningful and not based on very small subsets.</li>
          <li><b>Pure Nodes:</b> - All data points in a node belong to the same class, indicating that further splits would not improve the purity of the subsets.</li>
        </ul>

        <h4>Playing Tennis</h4>

        <p>Let's examine the "Playing Tennis" example more closely to illustrate how a decision tree works in practice.
        <ul>
          <li><a href="https://academy.hackthebox.com/storage/modules/290/decision_tree_tennis.png">https://academy.hackthebox.com/storage/modules/290/decision_tree_tennis.png</a></li>
        </ul>

        <p>Imagine you have a dataset of historical weather conditions and whether you played tennis on those days. For example:</p>

        <pre>
PlayTennis  Outlook_Overcast  Outlook_Rainy  Outlook_Sunny  Temperature_Cool  Temperature_Hot  Temperature_Mild  Humidity_High  Humidity_Normal  Wind_Strong  Wind_Weak
----------  ----------------  -------------  -------------  ----------------  ---------------  ----------------  -------------  ---------------  -----------  ---------
No          False             True           False          True              False            False             False          True             False        True
Yes         False             False          True           False             True             False             False          True             False        True
No          False             True           False          True              False            False             True           False            True         False
No          False             True           False          False             True             False             True           False            False        True
Yes         False             False          True           False             False            True              False          True             False        True
Yes         False             False          True           False             True             False             False          True             False        True
No          False             True           False          False             True             False             True           False            True         False
Yes         True              False          False          True              False            False             True           False            False        True
No          False             True           False          False             True             False             False          True             True         False
No          False             True           False          False             True             False             True           False            True         False
        </pre>

        <p>The dataset includes the following features:
        <ul>
          <li>Outlook: Sunny, Overcast, Rainy</li>
          <li>Temperature: Hot, Mild, Cool</li>
          <li>Humidity: High, Normal</li>
          <li>Wind: Weak, Strong</li>
        </ul>

        <p>The target variable is Play Tennis: Yes or No.</p>

        <p>A decision tree algorithm would analyze this dataset to identify the features that best separate the "Yes" instances from the "No" instances. It would start by calculating each feature's information gain or Gini impurity to determine which provides the most informative split.</p>

        <p>For instance, the algorithm might find that the Outlook feature provides the highest information gain. This means splitting the data based on whether sunny, overcast, or rainy leads to the most significant reduction in entropy or impurity.</p>

        <p>The root node of the decision tree would then be the Outlook feature, with three branches: Sunny, Overcast, and Rainy. Based on these branches, the dataset would be divided into three subsets.</p>

        <p>Next, the algorithm would analyze each subset to determine the best feature for the next split. For example, in the "Sunny" subset, Humidity might provide the highest information gain. This would lead to another internal node with High and Normal branches.</p>

        <p>This process continues recursively until a stopping criterion is met, such as reaching a maximum depth or a minimum number of data points in a node. The final result is a tree-like structure with decision rules at each internal node and predictions (Play Tennis: Yes or No) at the leaf nodes.</p>

        <h4>Data Assumptions</h4>

        <p>One of the advantages of decision trees is that they have minimal assumptions about the data:
        <ul>
          <li><b>No Linearity Assumption:</b> - Decision trees can handle linear and non-linear relationships between features and the target variable. This makes them more flexible than algorithms like linear regression, which assume a linear relationship.</li>
          <li><b>No Normality Assumption:</b> - The data does not need to be normally distributed. This contrasts some statistical methods that require normality for valid inferences.</li>
          <li><b>Handles Outliers:</b> - Decision trees are relatively robust to outliers. Since they partition the data based on feature values rather than relying on distance-based calculations, outliers are less likely to have a significant impact on the tree structure.</li>
        </ul>

        <p>These minimal assumptions contribute to decision trees' versatility, allowing them to be applied to a wide range of datasets and problems without extensive preprocessing or transformations.</p>

      </div>
      <hr>

      <div id="labs-table">

        <h4><a href="../fundamentalsAI.htm">Fundamentals of AI</a></h4>
        <ol>
          <li><a href="introductionMachineLearning.htm">Introduction to Machine Learning</a></li>
          <li><a href="mathematicsRefresherAI.htm">Mathematics Refresher for AI</a></li>
          <li><a href="supervisedLearningAlgorithms.htm">Supervised Learning Algorithms</a></li>
          <li><a href="linearRegression.htm">Linear Regression</a></li>
          <li><a href="logisticRegression.htm">Logistic Regression</a></li>
          <li><a href="decisionTrees.htm"><b><em>~ Decision Trees</em></b></a></li>
          <li><a href="naiveBayes.htm">Naive Bayes</a></li>
        </ol>
      </div>
      <hr>

    </div>
  </div>

  <div id="footer">
    <p>
      Webpage made by <a href="mailto:kappajester83@gmail.com">Kappa </a>
    </p>
  </div>

</html>